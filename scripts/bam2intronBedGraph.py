#!/usr/bin/env python
# Programmer : zhuxp
# Date: 
# Last-modified: 01-10-2014, 11:57:58 EST
VERSION="0.1"
import os,sys,argparse
from xplib.Annotation import Bed
from xplib import TableIO,Tools,DBI
from xplib.Tools import IO
import signal
signal.signal(signal.SIGPIPE,signal.SIG_DFL)
import gzip
import time
import multiprocessing as mp
import array,tempfile,heapq
assert array.array('i').itemsize==4
MAX_ARRAY_SIZE=500000
def ParseArg():
    ''' This Function Parse the Argument '''
    p=argparse.ArgumentParser( description = 'Example: %(prog)s -h', epilog='Library dependency : xplib')
    p.add_argument('-v','--version',action='version',version='%(prog)s '+VERSION)
    p.add_argument('-i','--input',dest="input",default="stdin",type=str,help="input file DEFAULT: STDIN")
    p.add_argument('-o','--output',dest="output",type=str,default="stdout",help="output file DEFAULT: STDOUT")
    p.add_argument('-n','--num_cpus',dest="num_cpus",type=int,default=4,help="number of cpus DEFAULT: %(default)i")
    p.add_argument('-s','--strand',dest="strand",type=str,choices=["read1","read2"],default="read2",help="read1 or read2 is the positive strand , default: %(default)s")
    p.add_argument('--prefix',dest="prefix",type=str,default="I",help="prefix for bed name default: %(default)s")
    p.add_argument('--cutoff',dest="cutoff",type=int,default=1,help="only report region covrage >= cutoff : %(default)i")
    if len(sys.argv)==1:
        print >>sys.stderr,p.print_help()
        exit(0)
    return p.parse_args()
def Main():
    '''
    IO TEMPLATE
    '''
    global args,out,dbi
    args=ParseArg()
    dbi=DBI.init(args.input,"bam")
    out=IO.fopen(args.output,"w")
    '''
    END OF IO TEMPLATE 
    '''
    print >>out,"# This positive_data was generated by program ",sys.argv[0]," (version: %s)"%VERSION,
    print >>out,"in bam2x ( https://github.com/nimezhu/bam2x )"
    print >>out,"# Date: ",time.asctime()
    print >>out,"# The command line is :"
    print >>out,"#\t"," ".join(sys.argv)
    chrs=[]
    for i in dbi.query(method="references"):
        chrs.append(i)
    p=mp.Pool(processes=args.num_cpus)    
    results=p.map(process_chrom,chrs)
    output(results)
    #process_chrom("chr1")
def output(results):
    for i in results:
        for j in i:
            print >>out,j

from xplib.Turing import TuringCode
from xplib.Turing import TuringCodeBook as cb


def process_chrom(chrom):
    retv=list()
    a=[]
    positive_data=[[]]
    negative_data=[[]]
    k=0
    negative_k=0
    for i in dbi.query(chrom,method="bam1",strand=args.strand):
        if i.strand=="+" or i.strand==".": 
            #heapq.heappush(positive_data[0],TuringCode(i.start,cb.ON))
            #heapq.heappush(positive_data[0],TuringCode(i.stop,cb.OFF))
            k+=2
            for j in i.Introns():
                heapq.heappush(positive_data[0],TuringCode(j.start,cb.BLOCKON))
                heapq.heappush(positive_data[0],TuringCode(j.stop,cb.BLOCKOFF))
                k+=2
            if k>MAX_ARRAY_SIZE:
                positive_data[0].sort()
                f=tempfile.TemporaryFile()
                positive_data.append(codes_from_file_iterator(f))
                codes_write_to_file(positive_data[0],f)
                f.seek(0)
                positive_data[0]=[]
                k=0
        else:
            #heapq.heappush(negative_data[0],TuringCode(i.start,cb.ON))
            #heapq.heappush(negative_data[0],TuringCode(i.stop,cb.OFF))
            negative_k+=2
            for j in i.Introns():
                heapq.heappush(negative_data[0],TuringCode(j.start,cb.BLOCKON))
                heapq.heappush(negative_data[0],TuringCode(j.stop,cb.BLOCKOFF))
                negative_k+=2
            if negative_k>MAX_ARRAY_SIZE:
                negative_data[0].sort()
                f=tempfile.TemporaryFile()
                negative_data.append(codes_from_file_iterator(f))
                codes_write_to_file(negative_data[0],f)
                f.seek(0)
                negative_data[0]=[]
                negative_k=0

    #print "positive_data length:",len(positive_data)
    positive_data[0].sort()
    cutoff=args.cutoff
    for i,x in enumerate(codesToBedGraph(heapq.merge(*positive_data),cutoff)):
        name=args.prefix+"_"+chrom+"_p"+str(i)
        retv.append(Bed([chrom,x[0],x[1],name,x[2],"+"]))
    negative_data[0].sort()
    for i,x in enumerate(codesToBedGraph(heapq.merge(*negative_data),cutoff)):
        name=args.prefix+"_"+chrom+"_n"+str(i)
        retv.append(Bed([chrom,x[0],x[1],name,x[2],"-"]))
    retv.sort()
    return retv
def codesToBedGraph(iter,cutoff=1.0):
    a=iter.next()
    last_pos=a.pos
    counter=0
    for i in iter:
        if i.pos!=last_pos:
            if counter >= cutoff:
                yield (last_pos,i.pos,counter)
            last_pos=i.pos
        if i.code==cb.BLOCKON:
            counter+=1
        if i.code==cb.BLOCKOFF:
            counter-=1
    #if counter >= cutoff:
    #    yield (last_pos,i.pos,counter)
    raise StopIteration



def codes_from_file_iterator(f):
    while True:
        a = array.array("i")
        a.fromstring(f.read(4000))
        if not a:
            break
        for i in range(0,len(a),2):
            yield TuringCode(a[i],a[i+1])
def codes_write_to_file(a,f):
    b=array.array("i")
    for i in a:
        b.append(i.pos)
        b.append(i.code)
    b.tofile(f)



    
if __name__=="__main__":
    Main()








