#!/usr/bin/env python
# Programmer : zhuxp
# Date: 
# Last-modified: 01-14-2014, 21:10:40 EST
VERSION="0.1"
import os,sys,argparse
from xplib.Annotation import Bed
from xplib import TableIO,Tools,DBI
from xplib.Tools import IO
import signal
signal.signal(signal.SIGPIPE,signal.SIG_DFL)
import gzip
import time
import multiprocessing as mp
import array,tempfile,heapq
import xplib.Stats.prob as prob
import itertools
assert array.array('i').itemsize==4
'''
V3:
DONE: mv sorting array to Turing Module
TODO: correct the coverage calculation

'''
EXON_GROUP_CODE=1
INTRON_GROUP_CODE=0
class Bed7(Bed):
    def __init__(self,x):
        Bed.__init__(self,x)
        self.group=x[6]
    def isExon(self):
        if self.group==EXON_GROUP_CODE:
            return True
        else:
            return False
    def isIntron(self):
        if self.group==INTRON_GROUP_CODE:
            return True
        else:
            return False


def ParseArg():
    ''' This Function Parse the Argument '''
    p=argparse.ArgumentParser( description = 'Example: %(prog)s -h', epilog='Library dependency : xplib')
    p.add_argument('-v','--version',action='version',version='%(prog)s '+VERSION)
    p.add_argument('-i','--input',dest="input",default="stdin",type=str,help="input file DEFAULT: STDIN")
    p.add_argument('-o','--output',dest="output",type=str,default="stdout",help="output file DEFAULT: STDOUT")
    p.add_argument('-n','--num_cpus',dest="num_cpus",type=int,default=4,help="number of cpus DEFAULT: %(default)i")
    p.add_argument('-s','--strand',dest="strand",type=str,choices=["read1","read2"],default="read2",help="read1 or read2 is the positive strand , default: %(default)s")
    p.add_argument('--prefix',dest="prefix",type=str,default="R",help="prefix for bed name default: %(default)s")
    p.add_argument('--cutoff',dest="cutoff",type=int,default=1,help="only report region covrage >= cutoff : %(default)i")
    p.add_argument('--pvalue',dest="pvalue",type=float,default=1e-05,help="cutoff for calling peak : %(default)f")
    if len(sys.argv)==1:
        print >>sys.stderr,p.print_help()
        exit(0)
    return p.parse_args()
def Main():
    '''
    IO TEMPLATE
    '''
    global args,out,exon_cutoff,intron_cutoff
    args=ParseArg()
    dbi=DBI.init(args.input,"bam")
    out=IO.fopen(args.output,"w")
    '''
    END OF IO TEMPLATE 
    '''
    print >>out,"# This positive_data was generated by program ",sys.argv[0]," (version: %s)"%VERSION,
    print >>out,"in bam2x ( https://github.com/nimezhu/bam2x )"
    print >>out,"# Date: ",time.asctime()
    print >>out,"# The command line is :"
    print >>out,"#\t"," ".join(sys.argv)
    chrs=[]
    lengths=[]
    for i in dbi.query(method="references"):
        chrs.append(i)
    for i in dbi.query(method="lengths"):
        lengths.append(i)
    p=mp.Pool(processes=args.num_cpus)    
    process_chrom("chr1")
    coverage_bedgraphs=p.map(process_chrom,chrs)
    #output(results)
    #TODO
    # BUG : coverage now related with cutoff
    # coverages=p.map(count_coverage,bedgraphs)
    bedgraphs=[]
    coverages=[]
    for i in range(len(chrs)):
        bedgraphs.append(coverage_bedgraphs[i][1])
        coverages.append(coverage_bedgraphs[i][0])
    s=0.0  # 1000.0
    l=long(0)
    for i in range(len(chrs)):
        s+=coverages[i]
        l+=lengths[i]
    l=l*2 # Double Strand
    coverage=s/l*1000.0
    threshold=1
    while 1:
        if prob.poisson_cdf(threshold,coverage,False) < args.pvalue: break
        threshold+=1
    exon_cutoff=threshold
    intron_cutoff=2 #TODO revise it
    print >>out,"# MEAN COVERAGE:",coverage
    print >>out,"# EXON COVERAGE CUTOFF:",exon_cutoff
    peaks=p.map(call_peaks_star,itertools.izip(bedgraphs,itertools.repeat(exon_cutoff)))
    output(peaks)

    #process_chrom("chr1")
def output(s):
    for i in s:
        for j in i:
            print >>out,j

from xplib.Turing import TuringCode
from xplib.Turing import TuringCodeBook as cb
from xplib.Turing import TuringSortingArray


def process_chrom(chrom):
    local_dbi=DBI.init(args.input,"bam")
    retv=list()
    intron_retv=list()
    a=[]
    #positive_data=TuringSortingArray(None,500)
    positive_data=TuringSortingArray()
    negative_data=TuringSortingArray()
    
    positive_intron_data=TuringSortingArray()
    negative_intron_data=TuringSortingArray()

    for i in local_dbi.query(chrom,method="bam1",strand=args.strand):
        if i.strand=="+" or i.strand==".": 
            positive_data.append(TuringCode(i.start,cb.ON))
            positive_data.append(TuringCode(i.stop,cb.OFF))
            for j in i.Exons():
                positive_data.append(TuringCode(j.start,cb.BLOCKON))
                positive_data.append(TuringCode(j.stop,cb.BLOCKOFF))
            for j in i.Introns():
                positive_intron_data.append(TuringCode(j.start,cb.BLOCKON))
                positive_intron_data.append(TuringCode(j.stop,cb.BLOCKOFF))
        else:
            negative_data.append(TuringCode(i.start,cb.ON))
            negative_data.append(TuringCode(i.stop,cb.OFF))
            for j in i.Exons():
                negative_data.append(TuringCode(j.start,cb.BLOCKON))
                negative_data.append(TuringCode(j.stop,cb.BLOCKOFF))
            for j in i.Introns():
                negative_intron_data.append(TuringCode(j.start,cb.BLOCKON))
                negative_intron_data.append(TuringCode(j.stop,cb.BLOCKOFF))
    cutoff=args.cutoff
    i0=0
    coverage=0.0
    for i,x in enumerate(codesToBedGraph(positive_data.iter())):
        if x[2] >= cutoff:
            name=args.prefix+"_E_"+chrom+"_p"+str(i0)
            retv.append(Bed7([chrom,x[0],x[1],name,x[2],"+",EXON_GROUP_CODE]))
            i0+=1
        coverage+=float(x[1]-x[0])*x[2]/1000.0

    i0=0
    for i,x in enumerate(codesToBedGraph(negative_data.iter())):
        if x[2] >= cutoff:
            name=args.prefix+"_E_"+chrom+"_n"+str(i0)
            retv.append(Bed7([chrom,x[0],x[1],name,x[2],"-",EXON_GROUP_CODE]))
            i0+=1
        coverage+=float(x[1]-x[0])*x[2]/1000.0
    i0=0
    INTRON_CUTOFF=1.0
    for i,x in enumerate(codesToBedGraph(positive_intron_data.iter())):
        if x[2] >= INTRON_CUTOFF:
            name=args.prefix+"_I_"+chrom+"_p"+str(i0)
            retv.append(Bed7([chrom,x[0],x[1],name,x[2],"+",INTRON_GROUP_CODE]))
            i0+=1

    i0=0
    for i,x in enumerate(codesToBedGraph(negative_intron_data.iter())):
        if x[2] >= INTRON_CUTOFF:
            name=args.prefix+"_I_"+chrom+"_n"+str(i0)
            retv.append(Bed7([chrom,x[0],x[1],name,x[2],"-",INTRON_GROUP_CODE]))
            i0+=1

    retv.sort()
    local_dbi.close()
    return coverage,retv
def codesToBedGraph(iter):
    a=iter.next()
    last_pos=a.pos
    counter=0
    for i in iter:
        if i.pos!=last_pos:
            yield (last_pos,i.pos,counter)
            last_pos=i.pos
        if i.code==cb.BLOCKON:
            counter+=1
        if i.code==cb.BLOCKOFF:
            counter-=1
    raise StopIteration


def call_peaks_star(a_b):
    return call_peaks(*a_b)
    
def call_peaks(bedgraph,exon_cutoff):
    #TODO
    gap=10
    pos_beds=[]
    neg_beds=[]
    peaks=[]
    i_p=0
    i_n=0
    last_pos_stop=0
    last_neg_stop=0
    for i in bedgraph:
        if i.strand=="+" or i.strand==".":
            if i.isExon():
                if i.score >= exon_cutoff:
                    if len(pos_beds)>0:
                        if  i.start-last_pos_stop < gap or last_pos_stop==0:
                            pos_beds.append(i)
                            if last_pos_stop < i.stop:
                                last_pos_stop=i.stop
                        else:
                            peaks.append(bedsToPeak(pos_beds,"p_"+str(i_p)))
                            i_p+=1
                            pos_beds=[i]
                            last_pos_stop=i.stop
                    else:
                        last_pos_stop=i.stop
                        pos_beds.append(i)
            elif i.isIntron():
                if last_pos_stop < i.stop:
                    last_pos_stop=i.stop
                pos_beds.append(i)
        else:
            if i.isExon():
                if i.score >= exon_cutoff:
                    if len(neg_beds)>0:
                        if  i.start-last_neg_stop < gap or last_neg_stop==0:
                            neg_beds.append(i)
                            if last_neg_stop < i.stop:
                                last_neg_stop=i.stop
                        else:
                            peaks.append(bedsToPeak(neg_beds,"n_"+str(i_n)))
                            i_n+=1
                            neg_beds=[i]
                            last_neg_stop=i.stop
                    else:
                        neg_beds.append(i)
                        last_neg_stop=i.stop
            elif i.isIntron():
                if last_neg_stop < i.stop:
                    last_neg_stop=i.stop
                pos_beds.append(i)

    if len(pos_beds)>0:
        peaks.append(bedsToPeak(pos_beds,"p_"+str(i_p)))
    if len(neg_beds)>0:
        peaks.append(bedsToPeak(neg_beds,"n_"+str(i_n)))
    peaks.sort()
    return peaks

def bedsToPeak(ibeds,id):
    peak=Bed([ibeds[0].chr,ibeds[0].start,ibeds[0].stop,id,float(ibeds[0].score),ibeds[0].strand])
    for i in ibeds[1:]:
        if i.isExon():
            peak.score=float(peak.score*len(peak)+i.score*len(i))/(len(peak)+len(i))
            peak.stop=i.stop
    print "META",peak
    for i in ibeds:
        print "IN",i
    return peak



        

    
if __name__=="__main__":
    Main()








