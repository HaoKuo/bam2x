#!/usr/bin/env python
# Programmer : zhuxp
# Date: 
# Last-modified: 12-06-2013, 10:43:01 EST
VERSION="0.1"
import os,sys,argparse
from xplib.Annotation import Bed
from xplib import TableIO,Tools,DBI
from xplib.Tools import IO
import signal
signal.signal(signal.SIGPIPE,signal.SIG_DFL)
import gzip
import time
import xplib.Turing.TuringCodeBook as cb
from xplib.Turing.TuringUtils import *
from xplib.Turing import TuringCode,TuringGraph
from bitarray import bitarray
from networkx.algorithms.approximation.clique import max_clique
import networkx as nx
from networkx.algorithms.clique import find_cliques

'''
Query bam and splicing sites
Construct Turing Graph
and translate reads into BitStr
    count reads number in each BitStr

get the possible path

score them?
'''
def ParseArg():
    ''' This Function Parse the Argument '''
    p=argparse.ArgumentParser( description = 'Example: %(prog)s -h', epilog='Library dependency : xplib')
    p.add_argument('-v','--version',action='version',version='%(prog)s '+VERSION)
    p.add_argument('-i','--input',dest="input",default="stdin",type=str,help="input file DEFAULT: STDIN")
    p.add_argument('-I','--input_format',dest="format",default="bed",type=str,help="input file format")
    p.add_argument('-o','--output',dest="output",type=str,default="stdout",help="output file DEFAULT: STDOUT")
    p.add_argument('-s','--splicing_sites',dest="splicing_sites",type=str,help="splicing sites [tabix file] [ output of xBamToSplicingSites.py ]")
    p.add_argument('-b','--bam',dest="bam",type=str,help="bam file")
    p.add_argument('-S','--strand',dest="strand",type=str,choices=["read1","read2"],default="read2",help="bam file")
    
    if len(sys.argv)==1:
        print >>sys.stderr,p.print_help()
        exit(0)
    return p.parse_args()
def Main():
    '''
    IO TEMPLATE
    '''
    global args,out,dbi_splicing,dbi_bam,g
    MAX_ITER_PATH_NUMBER=10000
    args=ParseArg()
    fin=IO.fopen(args.input,"r")
    out=IO.fopen(args.output,"w")
    '''
    END OF IO TEMPLATE 
    '''
    print >>out,"# This data was generated by program ",sys.argv[0]," (version: %s)"%VERSION,
    print >>out,"in bam2x ( https://github.com/nimezhu/bam2x )"
    print >>out,"# Date: ",time.asctime()
    print >>out,"# The command line is :"
    print >>out,"#\t"," ".join(sys.argv)
    header=["chr","start","end","id","score","strand","seq"];
    dbi_splicing_sites=DBI.init(args.splicing_sites,"tabix",tabix="metabed",header=header);
    dbi_bam=DBI.init(args.bam,"bam",method="bam2")


    for i0,i in enumerate(TableIO.parse(fin,args.format)):
        print >>out,"BEGIN\nQR\t",i
        l=list()
        l.append(TuringCode(0,cb.ON))
        l.append(TuringCode(0,cb.BLOCKON))
        l.append(TuringCode(len(i),cb.OFF))
        l.append(TuringCode(len(i),cb.BLOCKOFF))
        for j in dbi_splicing_sites.query(i):
            '''
            To Do query read2
            '''
            code=Tools.translate_coordinates(i,j)
            print >>out,"CODE\t",code
            if code.strand=="+":
                if code.id[0]=="a":
                    l.append(TuringCode(code.start+2,cb.BLOCKON))
                if code.id[0]=="d":
                    l.append(TuringCode(code.start,cb.BLOCKOFF))
        g=TuringGraph(l)
        bitarray_path=bitarray(2*len(g))
        bitarray_path.setall(True)
        print >>sys.stderr,"processing",i0," entry:",i
        print >>out,"FIGURE\t",g.graph_str(600)
        paths_number=g.count_paths_number()
        print >>out,"PATH_NUMBER\t",paths_number
        print >>sys.stderr,"path number:",paths_number
        h={}
        hc={}
        j0=0;
        for j in dbi_bam.query(i,method="bam2",strand=args.strand):
            p=[]
            for k in j:
                p.append(TuringFactory(Tools.translate_coordinates(i,k)))
            a=g.translate_paths_into_bits(p)
            if isSelfIncompatible(a): continue
            if h.has_key(a.tobytes()):
                h[a.tobytes()]+=1
                if hc[a.tobytes()]!=a:
                    print >>sys.stderr,"WARNING"
            else:
                h[a.tobytes()]=1
                hc[a.tobytes()]=a
            j0+=1
        print >>out,"PATTERN_NUMBER\t",len(h.keys())
        print >>out,"FRG_NUMBER\t",j0
        print >>sys.stderr,"fragments number:",j0
        print >>sys.stderr,"path pattern number:",len(h.keys())
        sorted_keys=sorted(h,key=h.get,reverse=True)    
        clique=[]
        cliques=[clique]
        bits=bitarray(len(g)*2)
        bits.setall(True)
        cliques_pattern=[bits]
        for j,key in enumerate(sorted_keys):
            print >>out,"No."+str(j),"\t",hc[key],h[key]
            joined_clique=False
            for m,clique in enumerate(cliques):
                if isCompatible(cliques_pattern[m],hc[sorted_keys[j]]):
                    joined_clique=True
                    cliques[m].append(j)
                    cliques_pattern[m]=bitarray_and(cliques_pattern[m],hc[sorted_keys[j]])
                    break
            if not joined_clique:
                clique=[]
                bits=bitarray(len(g)*2)
                bits.setall(True)
                max_index=0
                clique.append(j)
                bits=bitarray_and(bits,hc[sorted_keys[j]])
                cliques.append(clique)
                cliques_pattern.append(bits)
        print >>out,"OUTPUT"

        #update all cliques pattern.
        for j,x in enumerate(cliques):
            score=0
            c=[]
            for k,y in enumerate(sorted_keys):
                if isCompatible(cliques_pattern[j],hc[y]):
                    cliques_pattern[j]=bitarray_and(cliques_pattern[j],hc[y])
                    score+=h[y]
                    c.append(k)
            cliques_pattern[j][-1]=True
            cliques_pattern[j][-2]=True
            uniq_score=0
            for k,y in enumerate(x):
                uniq_score+=h[sorted_keys[y]]

            print >>out,"NO."+str(j)+" CLIQUE"    

            print >>out,"CLIQUE\t",c,"\nUNIQ\t",cliques[j],"\nPATTERN\t",cliques_pattern[j]
            bed=g.translate_bits_into_bed(cliques_pattern[j])
            bed.score=score
            bed.chr=i.id
            bed.id=i.id+"_"+"NO."+str(j)
            print >>out,"UNIQ_SCORE\t",uniq_score
            print >>out,"TR\t",bed
            print >>out,"UNIQ\t",uniq_score,"\tBED\t",Tools.translate_coordinates(i,bed,True)
            print >>out,""
        print >>out,"END"
        print >>out,""
        print >>out,""



        

    
def network_construct(bitarray_paths):
    G=nx.Graph()
    G.add_nodes_from(bitarray_paths)
    for i in bitarray_paths:
        for j in bitarray_paths:
            if isCompatible(i,j):
                G.add_edge(i,j)
    return G


def count_xor(path):
    s=0
    for i in range(0,len(path),2):
        if path[i]^path[i+1]: s+=1 # ^ is xor 
    return s        

def isCompatible(pathA,pathB):  ##pathA and B shoulc be same length
    for i in range(0,len(pathA),2):
        if not (pathA[i]&pathB[i] | pathA[i+1]&pathB[i+1]):
            return False
    return True
def isSelfIncompatible(pathA):
    for i in range(0,len(pathA),2):
        if not pathA[i]:
            if not pathA[i+1]:
                return True
    return False

def isOverlap(pathA,pathB):   ## Fir paired end reads overlap is not start > stop, overlap definition is not the same as overlap reades
    for i in range(0,len(path),2):
        if (pathA[i]^pathA[i+1]) and (pathB[i]^pathB[i+1]):
            return True
    return False

def findConsensusPath(paths):
    pass
    
if __name__=="__main__":
    Main()

