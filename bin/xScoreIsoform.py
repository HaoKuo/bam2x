#!/usr/bin/env python
# Programmer : zhuxp
# Date: 
# Last-modified: 09-04-2013, 11:26:12 EDT
VERSION="0.1"
import os,sys,argparse
from xplib.Annotation import Bed
from xplib import TableIO
from xplib.Tools import *
from xplib import DBI,Tools
import signal
signal.signal(signal.SIGPIPE,signal.SIG_DFL)
import gzip
import time
import math
'''
Input of this program is a set of isoforms  and bam file.
this program compare isoforms of a transcript with the reads overlap with the transcript region.
and using EM and BYYHardCut Algorithm to guess the distribution of isoforms
'''
def ParseArg():
    ''' This Function Parse the Argument '''
    p=argparse.ArgumentParser( description = 'xScoreIsoform.py , Input of this program is a set of isoforms  and bam file. this program compare isoforms of a transcript with the reads overlap with the transcript region. and using EM and BYYHardCut Algorithm to guess the distribution of isoforms', epilog='Library dependency : xplib')
    p.add_argument('-v','--version',action='version',version='%(prog)s '+VERSION)
    p.add_argument('-i','--input',dest="input",default="stdin",type=str,help="input file DEFAULT: STDIN")
    p.add_argument('-b','--bam',dest="bam",type=str,help="bamfile which containes RNA-Seq reads, or bamlist file that list bam files.")
    p.add_argument('-f','--format',dest="format",type=str, choices=["bam","bamlist"],default="bam",help="database format (bam or bamlist)")
    
    p.add_argument('-o','--output',dest="output",type=str,default="stdout",help="output file DEFAULT: STDOUT")
    p.add_argument('-t','--threshold',dest="threshold",type=float,default=0.01,help="Isoform Proportion larger than threshold is reported as HT (hit). other isoforms are reported as NT (no hit). default: 0.01")
    p.add_argument('-B','--BYY',dest="BYY",default=False,action="store_true",help="Using BYY HardCut")
    p.add_argument('-s','--hits_only',dest="hits_only",default=False,action="store_true",help="only report hits")
    
    if len(sys.argv)==1:
        print >>sys.stderr,p.print_help()
        exit(0)
    return p.parse_args()

def Main():
    '''
    IO TEMPLATE
    '''
    global args,out,dbi
    args=ParseArg()
    if args.output=="stdout":
        out=sys.stdout
    else:
        try:
            out=open(args.output,"w")
        except IOError:
            print >>sys.stderr,"can't open file ",args.output,"to write. Using stdout instead"
            out=sys.stdout
    if args.input=="stdin":
        fin=sys.stdin
    else:
        try:
            x=args.input.split(".")
            if x[-1]=="gz":
                fin=gzip.open(args.input,"r")
            else:
                fin=open(args.input,"r")
        except IOError:
            print >>sys.stderr,"can't read file",args.input
            fin=sys.stdin
    '''
    END OF IO TEMPLATE 
    '''
    print >>out,"# This data was generated by program ",sys.argv[0]," (version: %s)"%VERSION,
    print >>out,"in bam2x ( https://github.com/nimezhu/bam2x )"
    print >>out,"# Date: ",time.asctime()
    print >>out,"# The command line is :"
    print >>out,"#\t"," ".join(sys.argv)

    dbi=DBI.init(args.bam,args.format)
    '''
    reading all the isoforms
    '''
    beds=[]
    for i in TableIO.parse(fin,"bed"):
        beds.append(i)
    print >>sys.stderr,"sorting beds....\r",
    beds.sort()
    print >>sys.stderr,"sort beds done....\r",
    if len(beds)<1:
        print >>sys.stderr,"ERROR in reading file ",args.input
        print >>sys.stderr,"Please check if ",args.input," is  bed12 format file"
        exit(1)
    beds_len=len(beds)
    isoforms=[]
    bed=beds[0]
    chr=bed.chr
    min_start=bed.start
    max_stop=bed.stop
    j=0
    for i in beds:
        j+=1
        if (j%10==0): print >>sys.stderr,"processed %d /"%j,beds_len,"entries\r",
        if Tools.overlap(bed,i):
            if bed.stop < i.stop:
                bed.stop=i.stop
            isoforms.append(i)
        else:
            compare_reads(isoforms)
            isoforms=[i]
            bed=i
    if len(isoforms)>0:
        compare_reads(isoforms)



def compare_reads(isoforms):
    # global dbi,out
    isoforms_set=[]
    chr=isoforms[0].chr
    min_start=isoforms[0].start
    max_stop=isoforms[0].stop
    for i in isoforms:
        if i.start < min_start: min_start=i.start
        if i.stop > max_stop: max_stop=i.stop
        isoforms_set.append(i)
#        print >>sys.stderr,"debug",i
    transcript_region=Bed([chr,min_start,max_stop]);
    print >>out,"REGION\t",chr,"\t",min_start,"\t",max_stop
    print >>out,"ISOFORM_INPUT_NUMBER\t",len(isoforms_set)

    
    '''
    reading all the reads in this transcript region
    '''
    reads_set=[]
    reads_num=0
    for i in dbi.query(transcript_region,method="fetch12"):
        reads_set.append(i)
        reads_num+=1


    '''
    compare two sets
    '''
    l=len(isoforms_set)
    bincodes={}
    total=reads_num
    if total==0: total=0.001
    for i in reads_set:
        bincode=0
        for j in isoforms_set:
            k=Tools.compatible_with_transcript(i,j)
            if k:
                bincode = (bincode<<1)+1
            else:
                bincode = bincode<<1
        if  bincodes.has_key(bincode):
            bincodes[bincode]+=1
        else:
            bincodes[bincode]=1
        
    
    init=[ 1.0/l for i in range(l) ]
    proportion=init
    '''
    EM Initialize
    '''

    '''
    E step
    '''
    totals=[0.0 for i in range(l)]
    new_proportion=[0.0 for i in range(l)]
    iterate_time=0;
    while(1):
        totals=[0.0 for i in range(l)]
        for code in bincodes.keys():
            row_total=0.0
            for j in range(l):
                if get_bit_n(j,l,code):
                    row_total+=proportion[j]
            for j in range(l):
                if get_bit_n(j,l,code):
                    totals[j]+=bincodes[code] * proportion[j] / row_total

        for i in range(l):
            new_proportion[i]=totals[i]/total
        '''
        M step
        '''
        #print >>sys.stderr,"proportion",proportion #debug
        #print >>sys.stderr,"new_proportion",new_proportion #debug
        #print >>sys.stderr,"total",total #debug
        #print >>sys.stderr,"totals",totals #debug
        dis=distance(proportion,new_proportion)
        proportion=new_proportion
        iterate_time+=1
        if(dis<1e-05): break;
        if(args.BYY and iterate_time > 10): break;
   
    '''
    BYY Hard Cut Algorithm
    '''
    while(args.BYY):
        totals=[0.0 for i in range(l)]
        for code in bincodes.keys():
            maxj=-1
            for j in range(l):
                if get_bit_n(j,l,code):
                   # totals[j]+=bincodes[code] * proportion[j] / row_total
                   if maxj==-1: maxj=j
                   elif proportion[j] > proportion[maxj]: maxj=j
            if maxj!=-1: totals[maxj]+=bincodes[code]
        #new_proportion=[0.0 for i in range(l)]
        for i in range(l):
            new_proportion[i]=totals[i]/total
        '''
        M step
        '''
        dis=distance(proportion,new_proportion)
        if(dis<1e-05): break;
        proportion=new_proportion
    # print >>out,proportion

    '''
    print isoforms
    '''
    for i,x in enumerate(isoforms_set):
        if proportion[i] > args.threshold:  
            if x.score==0.0:
                x.score=proportion[i]
                print >>out,"HT\t",x,"\t",proportion[i]
            else:
                print >>out,"HT\t",x,"\t",proportion[i]
        else:
            if not args.hits_only:
                if x.score==0.0:
                    x.score=proportion[i]
                    print >>out,"NT\t",x,"\t",proportion[i]
                else:
                    print >>out,"NT\t",x,"\t",proportion[i]
    print >>out,"//"

def get_bit_n(index,length,bitcode): # 0-index
    return ((1<<(length-1-index))&bitcode)>>(length-1-index)
    
def distance(p,q):
    d=0.0
    for i in range(len(p)):
        d+=(p[i]-q[i])**2
    return math.sqrt(d)

    

if __name__=="__main__":
    Main()





