#!/usr/bin/env python
# Programmer : zhuxp
# Date: 
# Last-modified: 12-04-2013, 16:49:21 EST
VERSION="0.1"
import os,sys,argparse
from xplib.Annotation import Bed
from xplib import TableIO,Tools,DBI
from xplib.Tools import IO
import signal
signal.signal(signal.SIGPIPE,signal.SIG_DFL)
import gzip
import time
import xplib.Turing.TuringCodeBook as cb
from xplib.Turing.TuringUtils import *
from xplib.Turing import TuringCode,TuringGraph
from bitarray import bitarray
from networkx.algorithms.approximation.clique import max_clique
import networkx as nx
from networkx.algorithms.clique import find_cliques

'''
Query bam and splicing sites
Construct Turing Graph
and translate reads into BitStr
    count reads number in each BitStr

get the possible path

score them?
'''
def ParseArg():
    ''' This Function Parse the Argument '''
    p=argparse.ArgumentParser( description = 'Example: %(prog)s -h', epilog='Library dependency : xplib')
    p.add_argument('-v','--version',action='version',version='%(prog)s '+VERSION)
    p.add_argument('-i','--input',dest="input",default="stdin",type=str,help="input file DEFAULT: STDIN")
    p.add_argument('-I','--input_format',dest="format",default="bed",type=str,help="input file format")
    p.add_argument('-o','--output',dest="output",type=str,default="stdout",help="output file DEFAULT: STDOUT")
    p.add_argument('-s','--splicing_sites',dest="splicing_sites",type=str,help="splicing sites [tabix file] [ output of xBamToSplicingSites.py ]")
    p.add_argument('-b','--bam',dest="bam",type=str,help="bam file")
    p.add_argument('-S','--strand',dest="strand",type=str,choices=["read1","read2"],default="read2",help="bam file")
    
    if len(sys.argv)==1:
        print >>sys.stderr,p.print_help()
        exit(0)
    return p.parse_args()
def Main():
    '''
    IO TEMPLATE
    '''
    global args,out,dbi_splicing,dbi_bam,g
    MAX_ITER_PATH_NUMBER=10000
    args=ParseArg()
    fin=IO.fopen(args.input,"r")
    out=IO.fopen(args.output,"w")
    '''
    END OF IO TEMPLATE 
    '''
    print >>out,"# This data was generated by program ",sys.argv[0]," (version: %s)"%VERSION,
    print >>out,"in bam2x ( https://github.com/nimezhu/bam2x )"
    print >>out,"# Date: ",time.asctime()
    print >>out,"# The command line is :"
    print >>out,"#\t"," ".join(sys.argv)
    header=["chr","start","end","id","score","strand","seq"];
    dbi_splicing_sites=DBI.init(args.splicing_sites,"tabix",tabix="metabed",header=header);
    dbi_bam=DBI.init(args.bam,"bam",method="bam2")


    for i in TableIO.parse(fin,args.format):
        print >>out,"QR\t",i
        l=list()
        l.append(TuringCode(0,cb.ON))
        l.append(TuringCode(0,cb.BLOCKON))
        l.append(TuringCode(len(i),cb.OFF))
        l.append(TuringCode(len(i),cb.BLOCKOFF))
        for j in dbi_splicing_sites.query(i):
            '''
            To Do query read2
            '''
            code=Tools.translate_coordinates(i,j)
            print >>out,"CODE\t",code
            if code.strand=="+":
                if code.id[0]=="a":
                    l.append(TuringCode(code.start+2,cb.BLOCKON))
                if code.id[0]=="d":
                    l.append(TuringCode(code.start,cb.BLOCKOFF))
        g=TuringGraph(l)
        bitarray_path=bitarray(2*len(g))
        bitarray_path.setall(True)
        print >>sys.stderr,"processing",i
        print >>out,"path figure:",g.graph_str(600)
        paths_number=g.count_paths_number()
        print >>out,"path number:",paths_number
        print >>sys.stderr,"path number:",paths_number
        h={}
        hc={}
        j0=0;
        for j in dbi_bam.query(i,method="bam2",strand=args.strand):
            p=[]
            for k in j:
                p.append(TuringFactory(Tools.translate_coordinates(i,k)))
            a=g.translate_paths_into_bits(p)
            if h.has_key(a.tobytes()):
                h[a.tobytes()]+=1
                if hc[a.tobytes()]!=a:
                    print >>sys.stderr,"WARNING"
            else:
                h[a.tobytes()]=1
                hc[a.tobytes()]=a
            j0+=1
        print >>out,"path pattern number:",len(h.keys())
        print >>out,"fragments number:",j0
        print >>sys.stderr,"fragments number:",j0
        print >>sys.stderr,"path pattern number:",len(h.keys())
        for key in h.keys():
            print >>out,"pattern\t",hc[key],"\t",h[key],"\t",count_xor(hc[key])

        if paths_number > MAX_ITER_PATH_NUMBER:
            find_cliques()
        else:
            for j in g.iter_turing_paths():
                print j.graph_str(600)
                bits=g.translate_path_into_bits(j)
                print bits
                bed=g.translate_bits_into_bed(bits)
                print bed
                print i
                bed2=Tools.translate_coordinates(i,bed,True)
                print bed2
        

def find_cliques():
    pass
    #TODO
    
def network_construct(bitarray_paths):
    G=nx.Graph()
    G.add_nodes_from(bitarray_paths)
    for i in bitarray_paths:
        for j in bitarray_paths:
            if isCompatible(i,j):
                G.add_edge(i,j)
    return G


def count_xor(path):
    s=0
    for i in range(0,len(path),2):
        if path[i]^path[i+1]: s+=1 # ^ is xor 
    return s        

def isCompatible(pathA,pathB):  ##pathA and B shoulc be same length
    for i in range(0,len(pathA),2):
        if not (pathA[i]&pathB[i] | pathA[i+1]&pathB[i+1]):
            return False
    return True

def isOverlap(pathA,pathB):   ## Fir paired end reads overlap is not start > stop, overlap definition is not the same as overlap reades
    for i in range(0,len(path),2):
        if (pathA[i]^pathA[i+1]) and (pathB[i]^pathB[i+1]):
            return True
    return False

def findConsensusPath(paths):
    pass
    
if __name__=="__main__":
    Main()

